# 组合模式（Composite）

## 特征

* 结构型设计模式

* 将对象组合成树状结构，并且能像使用独立对象一样使用它们

故得名`对象树（Object Tree）`

## 问题

设有两类对象：`产品`和`盒子`。一个`盒子`可以包含多个`产品`或者几个较小的`盒子`，小`盒子`又可以包含一些`产品`或更小的`盒子`，以此类推。  

![](https://img-blog.csdnimg.cn/20201005144116727.png)

现在的问题是怎么计算一个订单的总价格。现实世界中你可以打开所有盒子，把所有产品清出来，然后计算总价。但是程序中，你必须要事先知道所有`产品`和`盒子`的类别，所有盒子的嵌套层数及其他繁杂的细节信息。直接计算极不方便。

## 解决方案

组合模式建议使用一个**通用接口**与`盒子`和`产品`进行交互，并在该接口声明一个计算总价的方法。

至于方法，就是用处理树遍历的常用方法：递归，直到没有为止。这样你就无需了解构成树状结构的对象的具体类。调用通用接口进行同样的处理即可。

## 结构

![](https://img-blog.csdnimg.cn/20201005144116697.png)

1.**组件（Component）**：通用接口，该接口描述了书中简单项目和复杂项目所共有的操作。

2.**叶节点（leaf）**：基本结构，不包含子项目。

一般叶节点会完成大部分工作，因为它无法把工作指派给其他部分。

3.**容器（container）**：——又名“组合（composite）”——包含叶节点或其他容器等子项目的单位，

* 容器不知道子项目所属的具体类，通过通用的组件接口与其子项目交互。

* 容器接受到请求后会将工作分配给自己的子项目，处理中间结果，然后把最终结果返回给客户端。

4.**客户端（Client）**：通过组件接口与所有项目交互。

## Sample Code

```cpp

```

## 适合应用场景

* 需要实现树状对象结构
  
  组合模式提供了两种共享公共接口的元素类型：**简单叶结点**和**复杂容器**。容器中包含叶结点和其他容器，因此你可以`树状嵌套递归`对象结构。

* 希望客户端代码以**相同方式**处理简单和复杂元素
  
  组合模式所有元素都共用一个接口。因此客户端不需要在意使用的对象的具体类。

## 实现方式

* 确保应用的核心模型能够以树状结构表示。
  
  尝试将其分解为简单元素和容器，同时保证容器能同时包含简单元素和其他容器。

* 声明**组件**接口及一系列方法

* 创建一个叶节点类表示简单元素。
  
  叶结点类可以有多个。

* 创建一个容器类表示复杂元素。
  
  创建一个数组成员变量来存储对于其子元素的引用。因为这个容器需要同时保存叶节点和容器，因此请确保声明为**组件**接口类型。

* 在容器中定义添加和删除子元素的方法
  
  记住，这些操作在组件接口中声明并定义，尽管这回违反`接口隔离原则`（因为这些在叶结点类中并未覆盖，而是继承默认实现（为空）），但是这可以让客户端无差别地遍历所有元素，即使是组成树状结构的元素。
  
  PS：因为Add与Remove需要有不同的实现版本，需要多态支持，如果是pure virtual，那么leaf类也必须要实现，实际上没这个需要，因此只能virtual，而这也违反了`接口隔离原则`。


