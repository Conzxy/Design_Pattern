# 原型模式（Prototype）

## 特征

* 创建型设计模式

* 复制原有对象而无需使代码依赖它们所属的类

## 问题

一般，我们想生成一个与原有对象完全一样的对象就得新建一个属于相同类的对象，然后遍历所有成员进行复制，但是私有成员你可访问不了，这是问题1。

问题2，直接复制还得依赖于该类。

问题3，你只知道对象实现的接口，而不知道其所属的具体类

## 解决方案

将克隆过程委派给被克隆的实际对象，为所有支持克隆的对象声明一个通用接口，这个接口使得你可以克隆对象并无需与对象所属类耦合。

支持克隆的对象即为**原型**。克隆在一定程度上可以取代构造：

创建一系列不同类型的对象并以不同的方式对其进行配置。如果所需对象与预配置对象相同，那么只需克隆原型，而不需新建一个对象

（说穿了，原型模式基于一个很自然的想法：对其子类私有成员出手，委派接口给子类实现）

## 结构

![](https://img-blog.csdnimg.cn/2020110113133950.png)

* **原型**：提供克隆方法接口

* **具体原型**：实现克隆对象。除了将原始对象的数据复制到克隆体中外，有时需处理克隆过程的极端情况，比如克隆关联对象和梳理递归依赖等。

* **客户端**：复制实现了原型接口的任何对象

## [Sample Code](https://github.com/Conzxy/Design_Pattern/blob/main/src/Prototype.h)

## 适用场景

* 需要复制对象同时又希望代码独立于这些对象所属的具体类
* 与子类的区别仅在于其对象的初始化方式，可以通过该模式减少子类数量。别人创建（第三方）这些子类的目的可能是为了创建特定类型的对象

在一些类的成员变量保存的是基类指针，但是又想拷贝子类对象时，原型模式的克隆接口就能派上用场，避免了与子类对象的所属类耦合